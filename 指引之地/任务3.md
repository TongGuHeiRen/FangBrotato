# 核心系统任务清单（波次 / 战斗 / 生命）

## 1. 创建 波次管理器.tscn 场景

   `[ ]` 在“场景/”创建新场景，保存为 `波次管理器.tscn`。
   `[ ]` 添加 `Node` 作为根节点，命名为 `波次管理器`。
   `[ ]` 在 `波次管理器` 下添加 `Timer` 子节点，命名为 `波次计时器`，设置 `one_shot = true`。
   `[ ]` 在 `波次管理器` 下添加 `Timer` 子节点，命名为 `间隔计时器`，设置 `one_shot = false`、`autostart = false`。

## 2. 编写 波次管理器.gd 脚本

   `[ ]` 在“脚本/”创建新脚本 `波次管理器.gd`（继承 `Node`），并附加到根节点 `波次管理器`。
       `[ ]` 定义导出变量：`export var 波次表: Array[Dictionary]`（字段：`时长秒`、`每秒`、`数量上限`）、`export var 起始索引: int = 0`。
       `[ ]` 定义信号：`signal 波次开始(索引: int, 时长: float)`、`signal 波次结束(索引: int, 胜利: bool)`、`signal 请求生成(数量: int)`。
       `[ ]` 添加 `@onready` 变量引用子节点：`波次计时器`、`间隔计时器`。
       `[ ]` 定义状态变量：`当前索引: int = -1`、`当前配置: Dictionary = {}`、`已生成总数: int = 0`、`活动中: bool = false`。
       `[ ]` 实现 `开始波次(索引: int = 起始索引)`：
           读取 `波次表[索引]` 为当前配置；重置计数；发射 `波次开始`；启动两个计时器（`波次计时器.start(时长秒)`、`间隔计时器.start(1.0)`）。
       `[ ]` 实现 `结束当前波次(胜利: bool)`：
           停止两个计时器；`活动中 = false`；发射 `波次结束(当前索引, 胜利)`。
       `[ ]` 实现 `获取当前剩余时间() -> float`：
           返回 `波次计时器.time_left`（无则返回 0）。
       `[ ]` 在 `_ready()` 中连接信号：
           `波次计时器.timeout` -> 调用 `结束当前波次(true)` 并尝试 `call_deferred("开始波次", 当前索引 + 1)`；
           `间隔计时器.timeout` -> 计算当秒应生成数量（`min(每秒, 数量上限 - 已生成总数)`）并发射 `请求生成(数量)`、累计计数；达到上限可 `间隔计时器.stop()`。

## 3. 强化 敌人.tscn（受击区与血条）

   `[ ]` 打开 `场景/敌人.tscn`（根节点 `敌人`，类型 `CharacterBody2D`）。
   `[ ]` 在 `敌人` 下实例化 `res://overlap/hurtbox.tscn`，命名为 `受击区`（类型 `Hurtbox`）。
   `[ ]` 在 `敌人` 下添加 `CanvasLayer` 或 `Node2D`，命名为 `UI`。
   `[ ]` 在 `UI` 下添加 `ProgressBar`，命名为 `血条`，设置最小宽度与对齐，初期可设置 `visible = true` 便于调试。

## 4. 编写 敌人.gd 脚本（生命 / 受伤 / 死亡）

   `[ ]` 在“脚本/”创建或打开 `敌人.gd`（继承 `CharacterBody2D`），并附加到根节点 `敌人`。
       `[ ]` 定义导出变量：`export var 最大生命: int = 10`、`export var 奖励金币: int = 1`。
       `[ ]` 定义状态变量：`var 当前生命: int = 最大生命`。
       `[ ]` 添加 `@onready` 变量：`受击区: Hurtbox = $受击区`、`血条: ProgressBar = $UI/血条`。
       `[ ]` 定义信号：`signal 已死亡(奖励金币: int)`。
       `[ ]` 实现 `设置血条()`：更新 `血条.max_value`、`血条.value`。
       `[ ]` 实现 `受到伤害(伤害值: int)`：扣减 `当前生命`（不小于 0），调用 `设置血条()`，若为 0 则调用 `死亡()`。
       `[ ]` 实现 `死亡()`：发射 `已死亡(奖励金币)`，播放死亡动画（可选），然后 `queue_free()`。

## 5. 强化 玩家.tscn（攻击命中区与计时器）

   `[ ]` 打开 `场景/玩家.tscn`（根节点 `玩家`，类型 `CharacterBody2D`）。
   `[ ]` 在 `玩家` 下实例化 `res://overlap/hitbox.tscn` 或添加 `Area2D`，命名为 `攻击命中区`（若为 `Hitbox` 场景已自带 `Collision`）。
   `[ ]` 在 `玩家` 下添加 `Timer`，命名为 `攻击计时器`，设置 `one_shot = false`、`autostart = false`。
   `[ ]` 根据需要调整 `攻击命中区` 的 `CollisionShape2D` 尺寸与位置。

## 6. 编写 玩家.gd 脚本（攻击 / 命中）

   `[ ]` 在“脚本/”创建或打开 `玩家.gd`（继承 `CharacterBody2D`），并附加到根节点 `玩家`。
       `[ ]` 定义导出变量：`export var 攻击间隔: float = 0.5`、`export var 攻击伤害: int = 3`。
       `[ ]` 添加 `@onready` 变量：`攻击命中区: Area2D = $攻击命中区`、`攻击计时器: Timer = $攻击计时器`。
       `[ ]` 实现 `开始攻击()`：`攻击计时器.start(攻击间隔)`；启用 `攻击命中区`（若为 `Hitbox` 调用 `enable()`，否则设置 `monitoring = true`）。
       `[ ]` 实现 `停止攻击()`：`攻击计时器.stop()`；禁用 `攻击命中区`（若为 `Hitbox` 调用 `disable()`）。
       `[ ]` 在 `_ready()` 中连接：`攻击计时器.timeout` -> 触发一次攻击窗口（可播放动画），若为 `Hitbox` 则 `(攻击命中区 as Hitbox).set_damage(攻击伤害)`。
       `[ ]` 命中判定（2 选 1）：
           方案 A：使用普通 `Area2D`，连接 `area_entered(area)`，若 `area` 为 `Hurtbox`，获取敌人节点并调用 `敌人.受到伤害(攻击伤害)`。
           方案 B：使用 `Hitbox`，连接自定义信号 `hit_something(thing_hit, damage_dealt)` 并对敌人执行伤害处理。

## 7. 集成到 主场景.gd（信号对接与 UI）

   `[ ]` 在 `主场景.gd` 中 `preload` 并实例化 `波次管理器.tscn`（若未在场景树中），添加为 `主场景` 子节点。
   `[ ]` 连接 `波次管理器.请求生成(数量)` 到 `生成器.生成一组(数量)`（延续任务2的生成器实现）。
   `[ ]` 连接 `波次管理器.波次开始/波次结束` 到 UI 刷新函数（如 `HUD.设置波次(索引)`、`HUD.设置计时(秒)`），并控制生成器启停。
   `[ ]` 在 `_process()` 或定时器中，轮询 `波次管理器.获取当前剩余时间()` 并更新 HUD 倒计时显示。
   `[ ]` 在生成敌人后，为每个 `敌人` 连接 `已死亡` 信号：掉落实例化到“掉落容器”，并调用 `GameSession.增加金币(奖励金币)`。

## 8. 碰撞层与掩码（确保可命中）

   `[ ]` 将 `攻击命中区` 与 `受击区` 配置为可互相检测的 `collision_layer` / `collision_mask`。
   `[ ]` 确保与地图、掉落物等层分离，避免误触发（可参考项目现有层级约定）。

## 9. 测试与验证

   `[ ]` 在编辑器设置 `波次表`（示例：`[{时长秒:30, 每秒:2, 数量上限:20}, {时长秒:35, 每秒:3, 数量上限:35}]`）。
   `[ ]` 运行 `主场景`：确认进入第 1 波、HUD 显示波次与倒计时。
   `[ ]` 观察敌人按“每秒”速率生成，至“数量上限”后暂停生成；倒计时结束进入下一波。
   `[ ]` 玩家触发攻击时，靠近的敌人血条递减，降至 0 后死亡并（如已接入）掉落。
   `[ ]` 多波连续运行无报错；波次切换时生成逻辑与 UI 更新一致。

## 注意事项

   `[ ]` 使用 Godot 4.x 正确的类型与大小写（`CharacterBody2D` / `Area2D` / `ProgressBar` / `Timer`）。
   `[ ]` 优先使用 `Timer + 信号` 实现时序逻辑，避免在 `_process()` 中手动累加时间。
   `[ ]` 充分复用 `overlap/hitbox.tscn` 与 `overlap/hurtbox.tscn`，减少重复造轮子。
   `[ ]` 暂不做对象池优化；若后续需要再将生成与回收统一管理以提升性能。
